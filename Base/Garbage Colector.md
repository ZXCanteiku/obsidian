## Garbage Colector
aliases: 
	- "Garbage Colector"

**Сборщик мусора Java** — это процесс, с помощью которого программы Java автоматически управляют памятью. Программы Java компилируются в байт-код, который можно запускать на виртуальной машине Java, или сокращённо JVM. Когда программы Java запускаются на JVM, объекты создаются в куче — части памяти, выделенной для программы. Со временем некоторые объекты перестают быть нужными. Сборщик мусора находит эти неиспользуемые объекты и удаляет их, чтобы освободить память.

**Сборщик мусора (Garbage Collector) должен делать всего две вещи:**
- Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
- Освобождать память от мусора.

**Существует два подхода к обнаружению мусора:**
- _Reference counting_;
- _Tracing_
  
**Reference counting** (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика. Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.

Главная идея подхода **Tracing** (трассировка) состоит в утверждении, что живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (_GC Root_) и те объекты, которые доступны с живого объекта. Всё остальное - мусор.

Существует 4 типа корневых точки:
- Локальные переменные и параметры методов;
- Потоки;
- Статические переменные;
- Ссылки из JNI (Java Native Interface — стандартный механизм для запуска кода под управлением виртуальной машины Java (JVM), который написан на языках С/С++ или Ассемблере).
### Разновидности сборщиков мусора:

- [[Serial]] (последовательный) — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. На данный момент используется сравнительно редко, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. Использование Serial GC включается опцией `-XX:+UseSerialGC`.
- [[Parallel]] (параллельный) — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. Параллельный сборщик включается опцией `-XX:+UseParallelGC`.
- [[Concurrent Mark Sweep (CMS)]] — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти. Использование CMS GC включается опцией `-XX:+UseConcMarkSweepGC`.
- [[Garbage-First (G1)]] — создан для замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных. _G1_ включается опцией Java `-XX:+UseG1GC`.


---
Tags: #GC
Author: [[]]
Related: [[Java Core]]
URL: [[]]