## Garbage Colector
aliases: 
	- "Garbage Colector"

**Сборщик мусора Java** — это процесс, с помощью которого программы Java автоматически управляют памятью. Программы Java компилируются в байт-код, который можно запускать на виртуальной машине Java, или сокращённо JVM. Когда программы Java запускаются на JVM, объекты создаются в куче — части памяти, выделенной для программы. Со временем некоторые объекты перестают быть нужными. Сборщик мусора находит эти неиспользуемые объекты и удаляет их, чтобы освободить память.

**Сборщик мусора (Garbage Collector) должен делать всего две вещи:**
- Находить мусор - неиспользуемые объекты. (Объект считается неиспользуемым, если ни одна из сущностей в коде, выполняемом в данный момент, не содержит ссылок на него, либо цепочка ссылок, которая могла бы связать объект с некоторой сущностью приложения, обрывается);
- Освобождать память от мусора.

**Существует два подхода к обнаружению мусора:**
- _Reference counting_;
- _Tracing_
  
**Reference counting** (подсчёт ссылок). Суть этого подхода состоит в том, что каждый объект имеет счетчик. Счетчик хранит информацию о том, сколько ссылок указывает на объект. Когда ссылка уничтожается, счетчик уменьшается. Если значение счетчика равно нулю, - объект можно считать мусором. Главным минусом такого подхода является сложность обеспечения точности счетчика. Также при таком подходе сложно выявлять циклические зависимости (когда два объекта указывают друг на друга, но ни один живой объект на них не ссылается), что приводит к утечкам памяти.

Главная идея подхода **Tracing** (трассировка) состоит в утверждении, что живыми могут считаться только те объекты, до которых мы можем добраться из корневых точек (_GC Root_) и те объекты, которые доступны с живого объекта. Всё остальное - мусор.

Существует 4 типа корневых точки:
- Локальные переменные и параметры методов;
- Потоки;
- Статические переменные;
- Ссылки из JNI (Java Native Interface — стандартный механизм для запуска кода под управлением виртуальной машины Java (JVM), который написан на языках С/С++ или Ассемблере).
### Стратегия работы сборщика мусора

Все сборщики мусора HotSpot реализуют стратегию сбора мусора по поколениям, которая классифицирует объекты по возрасту. Идея сбора мусора по поколениям заключается в том, что большинство объектов недолговечны и будут готовы к сбору мусора вскоре после создания.

![[Pasted image 20241026142223.png]]

### В чем разница между классификацией объектов сборщиком мусора?

Мы можем разделить кучу на три секции:

- **Молодое поколение**: вновь созданные объекты начинают своё существование в Молодом поколении. Сборщик мусора дополнительно делит Молодое поколение на пространство Эдема, где начинают своё существование все новые объекты, и два пространства Выживших, куда он перемещает объекты из Эдема после завершения одного цикла сбора мусора. Когда объекты удаляются из Молодого поколения, это является незначительным событием сбора мусора.
- **Старое поколение:** в конечном итоге сборщик мусора перемещает долгоживущие объекты из Молодого поколения в Старое поколение. Когда объекты из Старого поколения попадают в мусорную корзину, это является крупным событием по сбору мусора.
- **Постоянная генерация:** JVM хранит метаданные, такие как классы и методы, в постоянной генерации. JVM собирает мусор из классов постоянной генерации, которые больше не используются.

Во время полной сборки мусора неиспользуемые объекты из всех поколений удаляются.
### Разновидности сборщиков мусора:

- [[Serial]] (последовательный) — самый простой вариант для приложений с небольшим объемом данных и не требовательных к задержкам. На данный момент используется сравнительно редко, но на слабых компьютерах может быть выбран виртуальной машиной в качестве сборщика по умолчанию. Использование Serial GC включается опцией `-XX:+UseSerialGC`.
- [[Parallel]] (параллельный) — наследует подходы к сборке от последовательного сборщика, но добавляет параллелизм в некоторые операции, а также возможности по автоматической подстройке под требуемые параметры производительности. Параллельный сборщик включается опцией `-XX:+UseParallelGC`.
- [[Concurrent Mark Sweep (CMS)]] — нацелен на снижение максимальных задержек путем выполнения части работ по сборке мусора параллельно с основными потоками приложения. Подходит для работы с относительно большими объемами данных в памяти. Использование CMS GC включается опцией `-XX:+UseConcMarkSweepGC`.
- [[Garbage-First (G1)]] — создан для замены CMS, особенно в серверных приложениях, работающих на многопроцессорных серверах и оперирующих большими объемами данных. _G1_ включается опцией Java `-XX:+UseG1GC`.

### Что запускает сборку мусора?

Процесс сборки мусора запускается различными событиями, которые сигнализируют сборщику мусора о необходимости освободить память.

Вот некоторые распространенные события, которые запускают Java Garbage Collection:

1. **Ошибка выделения памяти:** когда объект не может быть выделен в куче из-за нехватки свободного места, JVM запускает сборку мусора, чтобы освободить память.
2. **Размер кучи:** когда размер кучи достигает определённого порога, JVM запускает сборку мусора, чтобы освободить память и предотвратить ошибку OutOfMemoryError.
3. **System.gc():** вызов метода System.gc() может запустить сборку мусора, но не гарантирует, что она произойдёт.
4. **На основе времени:** некоторые алгоритмы сборки мусора, такие как G1 Garbage Collection, используют триггеры на основе времени для запуска сборки мусора.


---
Tags: #GC
Author: [[]]
Related: [[Java Core]]
URL: [[]]