## 1. Векторные часы (Vector Clocks)

### Общая идея

Векторные часы — это структура данных, которая позволяет определить, являются ли два события:

- **конкурирующими** (каждое «не знает» о другом)
- или **одно предшествует другому** по причинности

В отличие от физических часов, векторные часы отражают **логический** порядок (кто узнал о чьих изменениях раньше).

### Как устроены

1. Допустим, у нас $N$ процессов (узлов). Тогда **векторные часы** — это массив (или вектор) длины $N$.
2. Каждый узел $i$ хранит **свои** часы $VCi​$ — массив из $N$ чисел.
3. При любом локальном событии узел $i$ делает:

$$VCi[i]←VCi[i]+1$$

4. Если узел $i$ шлёт сообщение узлу $j$, то он **прикрепляет** к сообщению свой вектор $VCi$​. Когда $j$ принимает сообщение с вектором $VCmsg​$, он для каждого индекса $k$ делает:

$$VCj[k]←max⁡(VCj[k],VCmsg​[k)$$

А затем (при желании) ещё увеличивает $VCj[j]$ на 1, фиксируя факт «получено сообщение».

### Сравнение векторных часов

Пусть у событий $A$ и $B$ вектора $VC(A)$ и $VC(B)$.

- **$A→B$** (A произошло до B), если для всех $K$

$$VC(A)[k]  ≤  VC(B)[k]$$

и **хотя бы по одному** $k$ строгое неравенство.

- Если же компоненты «не упорядочены» (где-то $VC(A)$ больше, а где-то меньше), события считаются **конкурентными**.
### Применение

- Явное определение причинности: можно проверить, видел ли узел уже чужие обновления.
- Разрешение конфликтов в базе (Cassandra, Riak), где объект хранит «вектор версий».
- Диагностика распределённых логов.

### Ограничения

- Нужно знать (или динамически учитывать) общее число узлов, чтобы иметь индекс в векторе.
- При большом числе узлов вектор может быть очень «широким».