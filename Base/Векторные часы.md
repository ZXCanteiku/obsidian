### 1.1. Общая идея

**Векторные часы** — это структура данных, которая позволяет системе определить, являются ли два события:

- **конкурентными** (каждое «не знает» о другом), или
- одно событие **произошло до** другого (то есть есть причинно-следственная связь).

В отличие от обычных (физических) часов, векторные часы отражают **логический** (причинный) порядок, а не реальное время.

### 1.2. Как устроены

1. Предположим, у нас есть NNN процессов или узлов. Тогда **векторные часы** — это массив (или вектор) длиной NNN, где каждая позиция отвечает за «счётчик» соответствующего узла.
2. Каждый узел iii хранит свои **локальные** векторные часы VCiVC_iVCi​. В начале система может инициализировать все элементы каждого вектора нулями.
3. При любом локальном событии (например, выполнении операции, записи в базу и т.п.) узел увеличивает **свой** счётчик на 1: VCi[i]←VCi[i]+1.VC_i[i] \gets VC_i[i] + 1.VCi​[i]←VCi​[i]+1.
4. Если узел iii посылает сообщение узлу jjj, оно прикрепляет к сообщению **текущий** вектор VCiVC_iVCi​. Когда узел jjj принимает это сообщение, оно «сливает» (merge) полученный вектор с собственным, беря поэлементный максимум: VCj[k]←max⁡(VCj[k],VCreceived[k])для всех k.VC_j[k] \gets \max(VC_j[k], VC_{received}[k]) \quad \text{для всех } k.VCj​[k]←max(VCj​[k],VCreceived​[k])для всех k. После этого узел jjj может ещё увеличить свой локальный счётчик (фиксируя, что произошло локальное событие «получено сообщение»).

### 1.3. Сравнение векторных часов

Допустим, у нас есть два события AAA и BBB с векторами VC(A)VC(A)VC(A) и VC(B)VC(B)VC(B).

- Говорим, что **A→BA \to BA→B** (A происходит до B), если VC(A)[k]≤VC(B)[k]VC(A)[k] \le VC(B)[k]VC(A)[k]≤VC(B)[k] для **каждого** kkk, и хотя бы по одному kkk строго меньше.
- Если же в одних компонентах VC(A)VC(A)VC(A) больше, а в других меньше, т.е. вектора **несравнимы**, то события **конкурентны**.

### 1.4. Применение

- **Определение причинных зависимостей**: можно быстро понять, знал ли узел об изменениях из другого узла (сравнив вектора).
- **Разрешение конфликтов** в некоторых NoSQL-системах (Cassandra, Riak, etc.), где при записи у каждого объекта есть версия-вектор. Если векторы «не сравнимы», значит изменения были конкурентные, нужно сливать.
- **Диагностика** распределённых логов: помогает выстраивать события, когда нет глобальных часов.

### 1.5. Ограничения

- Нужно знать **число всех узлов** (или по крайней мере иметь уникальный индекс для каждого, чтобы формировать размер вектора).
- Если узлов очень много, вектор может стать очень «широким».
- Система должна аккуратно обновлять векторные часы при каждом событии и обмене сообщениями.