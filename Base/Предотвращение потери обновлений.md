## Предотвращение потери обновлений
aliases: 
	- "предотвращение потери обновлений"

---

### Предотвращение потери обновлений

Обсуждавшиеся до сих пор уровни [[Чтение зафиксированных данных]]  и [[Изоляция снимков состояния и воспроизводимое чтение]] в основном гарантировали, что транзакция только для чтения может встречаться в случае конкурентных операций записи. Вопрос двух транзакций, выполняющих одновременно операции записи, мы почти не затрагивали. Мы обсудили только  [[Грязное чтение]] и  [[Чтение зафиксированных данных]] — одну из возможных разновидностей конфликтов двойной записи (write-write conflict). Существует несколько других интересных видов конфликтов, возникающих между транзакциями, конкурентно записывающими данные. Самый известный из них — проблема потерянного обновления (lost update), проиллюстрированная на рис. 7.1 примером конкурентного увеличения счетчика двумя пользователями.
![[Pasted image 20241114211340.png]]

Проблема потерянного обновления может возникать, когда приложение читает значение из базы данных, меняет его и записывает обратно измененное значение (цикл чтения изменения записи). При конкурентном выполнении таких действий двумя транзакциями существует риск потери одного из изменений, поскольку вторая операция записи не учитывает предыдущего изменения (иногда говорят, что более поздняя операция записи затирает более раннее значение). Этот паттерн возникает в различных сценариях использования таких, как:
- увеличение счетчика или обновление баланса счета (требует чтения текущего значения, вычисления нового значения и записи обратно старого);
- выполнение локального изменения в составном значении, например, добавления элемента в список в JSON-документе (требует синтаксического разбора документа, выполнения изменения и записи обратно модифицированного документа);
- одновременное редактирование двумя пользователями страницы «Википедии», причем каждый из них сохраняет свои изменения путем отправки на сервер всего содержимого страницы, перезаписывая данные, содержащиеся в этот момент в базе.

Поскольку проблема встречается так часто, было разработано множество разнообразных ее решений:
- **[[Атомарные операции записи]]**
- **[[Явные блокировки]]**
- **[[Сравнение с обменом]]**
- **Разрешение конфликтов и репликация** - в реплицируемых базах данных предотвращение потери обновлений осложняется многократным копированием данных. В случаях [[Репликация без ведущего узла]] блокировки и сравнения с обменом неприменимы. В таких системах могут возникать конфликтующие версии данных, которые разрешаются с помощью кода приложения. Коммутативные атомарные операции, такие как приращение счетчика, работают оптимально в репликации, предотвращая потерю данных. Например, в Riak 2.0 используется автоматическое слияние обновлений для избежания потерь.

#### Автоматическое обнаружение потери обновлений

Чтобы предотвратить потерю обновлений, можно прерывать транзакцию при обнаружении потерь и повторять цикл чтения-изменения-записи. Это работает эффективно с изоляцией снимков состояния, например, в PostgreSQL, Oracle и SQL Server, но не в MySQL/InnoDB.

---
Tags: #transactions #highLoad
Author: [[]]
Related: [[Слабые уровни изоляции]]
URL: -- 