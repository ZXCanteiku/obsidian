

**1. (Открытый вопрос)** Объясните разницу между профилированием CPU и профилированием памяти в Java-приложении. Какие инструменты можно использовать для каждого вида профилирования?

**Ответ:** При **CPU-профилировании** основная цель – выяснить, какие участки кода занимают больше всего процессорного времени. Мы анализируем нагрузку на CPU: какие методы чаще всего выполняются, сколько времени они работают, где "узкие места" по производительности. Для этого применяются профилировщики, например, **Java Flight Recorder (JFR)**/Java Mission Control, **VisualVM**, **YourKit** или **JProfiler** – они позволяют собирать стастику по использованию CPU методом либо сэмплированием стека, либо инструментированием кода.

При **профилировании памяти** мы концентрируемся на использовании памяти: сколько объектов создается, где происходят утечки памяти, каков размер куч (heap) и т.п. Инструменты для этого включают сбор дампов памяти и их анализ (например, **jmap** + **jhat** или анализ дампа через VisualVM, Eclipse MAT). Можно также использовать профилировщики в режиме мониторинга памяти, отслеживать размер кучи, количество сборок мусора и объекты, занимающие много места. Иными словами, CPU-профилирование отвечает на вопрос "что загружает процессор", а профилирование памяти – "куда уходит память". Разные инструменты (JFR, VisualVM и др.) позволяют делать и то и другое, переключаясь в нужный режим.

**2. (Несколько вариантов)** Какие из следующих утверждений о профилировании верны? (выберите все правильные варианты)

- A. Сэмплирующие (sampling) профилировщики дают меньшую нагрузку на приложение, но могут пропустить кратковременные вызовы методов.
- B. Профилировщики, использующие инструментирование (instrumentation), могут менять байт-код методов, чтобы собирать информацию.
- C. Логи работы сборщика мусора (GC logs) бесполезны для анализа производительности приложения.
- D. Снимок кучи (heap dump) может помочь обнаружить утечки памяти.

- A верно: Сэмплирующие профилировщики периодически (с заданным интервалом) снимают состояние стека потока. Они менее нагружают приложение и почти не влияют на время выполнения, однако могут не зафиксировать очень короткие вызовы методов, из-за чего есть небольшая потеря точности.
- B верно: Профилирование с инструментированием вставляет дополнительный код в начало/конец методов или при доступе к полям для точного измерения времени и счетчиков. Такой подход позволяет собрать детальную информацию, но увеличивает оверхед и может замедлить приложение (иногда существенно).
- C неверно: Логи GC могут дать ценную информацию о паузах в работе приложения, частоте и длительности сборок мусора, объёме освобождаемой памяти. Анализ GC-логов помогает оптимизировать настройку памяти и понять, тратится ли много времени на сборку мусора – что, несомненно, влияет на производительность.
- D верно: Снимок кучи (heap dump) – это слепок состояния памяти в определённый момент, содержащий все объекты. Его анализ позволяет обнаружить утечки памяти (например, объекты, которые должны были быть удалены, но всё ещё достижимы), определить, какие объекты занимают основную часть памяти, и понять структуру потребления памяти приложением.