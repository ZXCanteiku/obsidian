

**1. (Открытый вопрос)** Объясните разницу между профилированием CPU и профилированием памяти в Java-приложении. Какие инструменты можно использовать для каждого вида профилирования?

**Ответ:** При **CPU-профилировании** основная цель – выяснить, какие участки кода занимают больше всего процессорного времени. Мы анализируем нагрузку на CPU: какие методы чаще всего выполняются, сколько времени они работают, где "узкие места" по производительности. Для этого применяются профилировщики, например, **Java Flight Recorder (JFR)**/Java Mission Control, **VisualVM**, **YourKit** или **JProfiler** – они позволяют собирать стастику по использованию CPU методом либо сэмплированием стека, либо инструментированием кода.

При **профилировании памяти** мы концентрируемся на использовании памяти: сколько объектов создается, где происходят утечки памяти, каков размер куч (heap) и т.п. Инструменты для этого включают сбор дампов памяти и их анализ (например, **jmap** + **jhat** или анализ дампа через VisualVM, Eclipse MAT). Можно также использовать профилировщики в режиме мониторинга памяти, отслеживать размер кучи, количество сборок мусора и объекты, занимающие много места. Иными словами, CPU-профилирование отвечает на вопрос "что загружает процессор", а профилирование памяти – "куда уходит память". Разные инструменты (JFR, VisualVM и др.) позволяют делать и то и другое, переключаясь в нужный режим.

**2. (Несколько вариантов)** Какие из следующих утверждений о профилировании верны? (выберите все правильные варианты)

- A. Сэмплирующие (sampling) профилировщики дают меньшую нагрузку на приложение, но могут пропустить кратковременные вызовы методов.
- B. Профилировщики, использующие инструментирование (instrumentation), могут менять байт-код методов, чтобы собирать информацию.
- C. Логи работы сборщика мусора (GC logs) бесполезны для анализа производительности приложения.
- D. Снимок кучи (heap dump) может помочь обнаружить утечки памяти.

- A верно: Сэмплирующие профилировщики периодически (с заданным интервалом) снимают состояние стека потока. Они менее нагружают приложение и почти не влияют на время выполнения, однако могут не зафиксировать очень короткие вызовы методов, из-за чего есть небольшая потеря точности.
- B верно: Профилирование с инструментированием вставляет дополнительный код в начало/конец методов или при доступе к полям для точного измерения времени и счетчиков. Такой подход позволяет собрать детальную информацию, но увеличивает оверхед и может замедлить приложение (иногда существенно).
- C неверно: Логи GC могут дать ценную информацию о паузах в работе приложения, частоте и длительности сборок мусора, объёме освобождаемой памяти. Анализ GC-логов помогает оптимизировать настройку памяти и понять, тратится ли много времени на сборку мусора – что, несомненно, влияет на производительность.
- D верно: Снимок кучи (heap dump) – это слепок состояния памяти в определённый момент, содержащий все объекты. Его анализ позволяет обнаружить утечки памяти (например, объекты, которые должны были быть удалены, но всё ещё достижимы), определить, какие объекты занимают основную часть памяти, и понять структуру потребления памяти приложением.

**3. (True/False)** Утилита **Java Flight Recorder (JFR)** предназначена для низконагрузочного профилирования и может безопасно использоваться даже на продакшн-серверах.

**Ответ:** **True.** JFR – это встроенный в JVM инструмент профилирования с малым оверхедом. Он разработан специально для работы в продакшене: собирает данные о производительности (CPU, память, блокировки, сборка мусора и др.) с минимальным влиянием на скорость работы приложения. Его можно запускать длительно в рабочей среде, а собранные им события затем анализировать (например, с помощью Java Mission Control). В отличие от некоторых внешних профилировщиков, JFR работает внутри JVM и очень эффективно, поэтому подходит для непрерывного мониторинга производительности на боевых серверах.


**4. (Открытый вопрос)** Объясните, как Spring реализует принцип _Inversion of Control_. Что происходит при запуске Spring-приложения с точки зрения создания и связывания бинов?

**Ответ:** **Inversion of Control (IoC)** в Spring означает, что создание объектов и управление зависимостями между ними передано самому фреймворку (контейнеру Spring), а не кодируется вручную в приложении. Проще говоря, вместо того чтобы каждый объект сам создавал свои зависимости (или программист вызывал `new`), контейнер Spring выступает фабрикой: он инстанцирует объекты и "впрыскивает" (inject) необходимые зависимости.

При запуске Spring-приложения (например, поднятии ApplicationContext):

1. **Сканирование конфигурации:** Контейнер читает конфигурацию. Это может быть XML-файл, Java-конфигурация (@Configuration классы с@Bean методами) или компонентный скан (по аннотациям @Component, @Service и т.д.).
    
2. **Создание бинов:** На основе конфигурации Spring определяет, какие классы являются бинами и какие зависимости им нужны. Он создаёт экземпляры этих классов. Обычно сначала создаются бины, от которых зависят другие (разрешение графа зависимостей).
    
3. **Внедрение зависимостей:** После создания экземпляров контейнер устанавливает необходимые связи. Если бин А зависим от бина B (например, через поле с @Autowired, через конструктор или сеттер), контейнер Spring находит подходящий бин B и присваивает его ссылку внутрь А. Это и есть _dependency injection_ – зависимости передаются извне в объект.
    
4. **Инициализация:** Если у бина есть методы lifecycle (например, аннотация @PostConstruct или имплементация InitializingBean), Spring вызовет их, позволяя бинуа выполнить доп. настройку после инъекции зависимостей.
    
5. **Готовность:** После этого бины готовы к использованию, и контейнер может выдавать их по запросу или начать обслуживание веб-запросов, если это веб-приложение.
    

Таким образом, управление созданием объектов инвертировано: код приложения не создает объекты напрямую, а только описывает, какие зависимости нужны. Spring-container берёт на себя эту работу, что упрощает конфигурацию, тестирование (можно подменять зависимости) и декларирование связей между компонентами.