## О чем эта заметка
aliases: 
	- "Репликация без ведущего узла"

---

### Как работает репликация без ведущего узла?

Репликация данных бывает двух типов: с ведущим узлом и без ведущего узла. В репликации с ведущем узлом все записи сначала отправляются на один узел (ведущий), который определяет порядок их применения, а остальные реплики следуют этому порядку. В репликации без ведущего узла любой узел может принимать записи напрямую от клиентов. Такая схема использовалась в ранних системах, но с развитием реляционных баз данных потеряла популярность. Она снова стала актуальной с появлением системы Dynamo от Amazon, на основе которой работают Riak, [[Cassandra]] и Voldemort.

В системах без ведущего узла клиент может отправлять записи на несколько реплик одновременно, и если одна реплика недоступна, другие обрабатывают запросы. После успешной обработки хотя бы двумя из трёх реплик запись считается успешной. Однако это может привести к устареванию данных на недоступной реплике, когда она снова становится доступной. Чтобы избежать этого, данные восстанавливаются через чтение с нескольких узлов параллельно. Если один узел возвращает старое значение, оно обновляется на нём с помощью более новой версии.

Для поддержания консистентности используются два основных механизма:

1. **Чтение с восстановлением (read repair)** – когда клиент обнаруживает устаревшие данные при чтении, он обновляет реплику с помощью актуального значения.
2. **Анти-энтропия** – фоновый процесс, который синхронизирует данные между репликами, копируя пропущенные записи.
![[Pasted image 20241009194011.png]]

Для управления чтениями и записями в системах без лидера применяют понятие кворума: запись считается успешной, если её подтверждают как минимум _w_ реплик, а для чтения необходимо получить ответы от как минимум _r_ реплик. Чтобы гарантировать актуальность данных при чтении, необходимо, чтобы сумма _w + r_ была больше, чем общее число реплик _n_. Например, при _n = 3, настройка w = 2_ и _r =2 позволяет системе работать даже при одном недоступном узле.

Условие кворума, w + r > n, позволяет системе выдерживать недоступные узлы следующим образом:  
  
- Если w < n, мы всё равно можем обрабатывать записи, если узел недоступен.
- Если r < n, мы всё равно можем обрабатывать чтения, если узел недоступен.
- С n = 3, w = 2, r = 2, мы можем выдержать один недоступный узел.
- С n = 5, w = 3, r = 3, мы можем выдержать два недоступных узла. Этот случай показан на Рисунке
![[Pasted image 20241009194155.png]]

Чтения и записи обычно отправляются параллельно на все реплики. Если система не может получить нужное количество подтверждений от узлов (например, из-за их недоступности), операция завершается с ошибкой. В целом, параметры _n_, _w_, и _r_ позволяют балансировать между скоростью и надёжностью системы, настраивая количество узлов для подтверждения записей и чтений.

Также стоит ознакомится с следующими темами:
- [[Ограничения согласованности по кворуму]]
- [[Нестрогие кворумы и направленная передача]]
- [[Обнаружение конкурентных операций записи]]



---
Tags: #highLoad #develop #replication
Author: [[]]
Related: [[Репликация данных]]
URL: -- 