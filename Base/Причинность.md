## Причинность
aliases: 
	- "Причинность"

---

## 1. Общая идея причинности

**Причинность** в контексте распределённых систем — это принцип соблюдения **логического порядка**: если одно событие (A) могло повлиять на другое событие (B), то A должно считаться «раньше» B (A → B).

- Если событие BBB каким-то образом зависит от результата AAA (например, BBB читает данные, записанные в AAA), мы говорим, что BBB _причинно следует_ за AAA.
- Если же события «не связаны» (никак не влияют друг на друга), мы считаем их **конкурентными**.

На практике «могло повлиять» часто означает, что результат события A был прочитан или доставлен участнику, который затем совершил B.

### Пример

- **Чат**: если сообщение «ответ» ссылается на «вопрос», то логично, что «вопрос» произошёл раньше «ответа». Если пользователь видит «ответ до вопроса», это выглядит нелогично (нарушение причинности).
- **Обновление записи**: чтобы изменить строку в БД, её нужно сначала создать. Если система «видит» обновление строки раньше, чем сама строка создана, это тоже нарушение причинности.

Таким образом, **причинность** — это то, что соответствует нашим интуитивным представлениям о «что было раньше, а что позже», с точки зрения «узлов», «сообщений» и «зависимостей».


## 2. Почему причинность не сводится к линеаризуемости

В **линеаризуемости** (strong consistency) предполагается, что все операции образуют **полный** порядок: каждая пара событий AAA и BBB может быть упорядочена (или AAA строго раньше, или BBB строго раньше).

**Причинность** слабее, чем линеаризуемость:

- **В причинности** конкурентные события нельзя упорядочить (их «кто раньше» не важен, потому что они не влияют друг на друга).
- **В линеаризуемости** даже конкурентные операции должны быть как-то «вписаны» в общую временную шкалу, где точно известно, кто «первее».

Таким образом, если система **линеаризуема**, она автоматически сохраняет и причинность (поскольку там есть строгий порядок, который не нарушает «что было раньше»). Но система может быть причинно согласованной **без** линеаризуемости, и это обычно проще (и быстрее) реализовать.

## 3. Как практически сохраняют причинность

- ***[[Векторные часы]]*** (vector clocks) - распространённая структура данных, которая позволяет определить, являются ли два события конкурентными или одно «происходит до» другого:
	- Каждый узел (процесс) имеет свой счётчик операций.
	- При отправке сообщения узел прикрепляет к нему свой «вектор» (список счётчиков по всем узлам).
	- Получатель при получении берёт максимум по каждому компоненту вектора, тем самым «синхронизируя» свой локальный вектор.
	- Если мы хотим сравнить события $E1$​ и $E2$​ с векторными метками $V1$​ и $V2$​, то:
	    - $E1→E2$ (A «происходит до» B), если $V1[i]≤V2[i$] для всех $i$ и хотя бы по одному $i$ строго меньше.
	    - Если $V1$​ и $V2$​ несравнимы (по одних измерениям больше, по других — меньше), тогда события конкурентны.

Векторные часы бывают сложны для масштабирования, если узлов очень много (потому что нужен вектор размером «число узлов»). Но в более «ограниченных» сценариях это классический и удобный механизм.

- ***[[Лампорта часы]]*** - упрощённый вариант, где есть **одна** числовая метка, которая монотонно возрастает. Она обеспечивает **полный** порядок, согласующийся с причинностью, но **не** может определить, являются ли события конкурентными или нет
- ***[[Причинно-следственная репликация]]***
## 4. Примеры нарушений причинности

Чтобы понять, чем грозит несохранение причинности, рассмотрим несколько типичных ситуаций:

1. **Устаревшие ответы**: Алиса узнаёт «новый счёт игры», Боб слышит это от Алисы (значит, «причинно знает»), но потом в БД видит «старый счёт». Боб понимает, что видел информацию, причинно более раннюю, чем новость от Алисы — путаница.
2. **Отправка сообщений через разные каналы**: если система A шлёт сигнал в систему B и C, и B передаёт дальнейший результат C, может оказаться, что C видит «сигнал из B», но не видит «из A», хотя по логике уже должен.
3. **Секционированные транзакции**: транзакция в одном разделе изменила строку, а другая операция в другом разделе её читает. Если нет механизма причинности, может появиться «фантомное» поведение, когда чтение идёт до записи и не «видит» нужных данных.
## 5. Как разработчикам учитывать причинность

1. **Согласованный снимок** (snapshot): когда мы хотим прочитать данные «на момент времени T», мы хотим быть уверены, что **все** события, которые «происходили до T», включены в снимок. Это исключает «ответ до вопроса».
2. **Устранение конфликтов записи**: если два пользователя независимо отредактировали одну сущность, а система пропустила, что одно обновление должно идти «после» другого, могут возникнуть коллизии. Явное хранение причинности (версий) помогает распознать и слить конфликт.
3. **Связанные сущности**: Если таблица «Пользователи» и «Профили» обновляются отдельно, но один зависит от другого, нужна продуманная схема согласования (вплоть до транзакций или хотя бы до causal consistency), чтобы избежать расхождений.
## 6. Итог и связь с другими моделями

- **Причинность** даёт частичный порядок. Система, которая её сохраняет, защищена от нелепых «нарушений логики» (вроде ответа до вопроса).
- **Линеаризуемость** (или сильная согласованность) даёт полный порядок, но дороже с точки зрения сетевых обменов (консенсус, лидер и т. п.).
- Модель **eventual consistency** вообще не даёт гарантий порядка; данные «когда-то синхронизируются», и временами бывают «аномалии» нарушенной причинности.
- **Causal consistency** — компромисс: она сильнее, чем eventual (не видим абсурдных reorder), но всё ещё легче (быстрее), чем строгая линеаризуемость.

### Основной вывод

1. **Причинность** отражает то, что «можно знать о прошлом»: если событие B происходит с учётом информации из A, то B не может «выглядеть раньше A».
2. **Практические решения** (векторные/лампортовские метки, causal consistency) позволяют избегать логических противоречий при репликации данных и пересылке сообщений.
3. При этом «причинно-следственная согласованность» (causal consistency) **не** требует полного глобального порядка; следовательно, она **менее затратна** по сети, чем линеаризуемость, и **более естественна** для ряда приложений (вроде совместного редактирования или систем Git-подобных версий).

Таким образом, **причинность** — важнейшая концепция, объясняющая, почему в распределённых системах события должны иметь согласованный порядок, пусть и не всегда «абсолютный», зато логически непротиворечивый для пользователя.

---
Tags: #highLoad #develop #coherence  #consensus
Author: [[]]
Related: [[Согласованность и консенсус]]
URL: -- 