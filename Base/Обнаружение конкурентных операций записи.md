## Обнаружение конкурентных операций записи
aliases: 
	- "обнаружение конкурентных операций записи"

---

Что такое конкурентная операция записи

Базы данных в динамическом стиле позволяют нескольким клиентам одновременно писать в один и тот же ключ, что означает, что конфликты будут возникать даже при использовании строгих кворумов. Ситуация аналогична репликации с несколькими лидерами, хотя в базах данных в динамическом стиле конфликты также могут возникнуть во время восстановления чтения или подсказки.  
  
Проблема в том, что события могут поступать в разном порядке к разным узлам из-за переменных сетевых задержек и частичных сбоев. Например, на рисунке 5-12 показаны два клиента, A и B, одновременно пишущие в ключ X в хранилище данных из трех узлов:  
  

- Узел 1 получает запись от A, но никогда не получает запись от B из-за временного сбоя.
- Узел 2 сначала получает запись от A, затем запись от B.
- Узел 3 сначала получает запись от B, затем запись от A.

![](https://optim.tildacdn.com/tild6432-6337-4466-b134-323739386164/-/resize/960x/-/format/webp/__2023-10-25__102702.png)

Если каждый узел просто перезаписывал бы значение для ключа каждый раз, когда он получал запрос на запись от клиента, узлы стали бы навсегда несогласованными, как показано в последнем запросе get на рисунке 5-12: узел 2 считает, что окончательное значение X — это B, тогда как другие узлы считают, что значение — это A.  
  
Чтобы в конечном итоге стать согласованными, реплики должны сходиться к одному и тому же значению. Как они это делают? Можно было бы надеяться, что реплицированные базы данных справятся с этим автоматически, но, к сожалению, большинство реализаций весьма недостаточны: если вы хотите избежать потери данных, вам, как разработчику приложения, нужно знать много о внутренностях обработки конфликтов вашей базы данных.

Способы разрешения этих конфликтов описаны ниже:
- 

---
Tags:
Author: [[]]
Related: [[]]
URL: -- 