## N+1
aliases: 
	- "N+1"

**Проблема N+1** возникает, когда ORM (например, Hibernate) выполняет избыточное количество запросов к базе данных для получения связанных данных. Эта проблема может сильно снизить производительность приложения, особенно при работе с большими объемами данных.

fetch = FetchType.EAGER и fetch = FetchType.LAZY не помогут решить проблему все равно будет n запросов

### Решение с помощью @EntityGraph и Решение с помощью Fetch
решает проблему N + 1 запросов но возникает проблема
- `Hibernate 6: WARN: HHH90003004: firstResult/maxResults specified with collection fetch; applying in memory`
из запроса исчезли limit и offset  и пагинация выполняется в памяти, что  

```java
@Entity 
public class Student { 
	@Id @GeneratedValue(strategy=GenerationType.AUTO) 
	private Long id; 
	private String name; // getters and setters 
}
```

- [[Виды генераций id]]
- [[Маппинг полей]]
- [[Отношения между сущностями]]

### Проблемы с неизменяемыми коллекциями и Lombok:
- **Неизменяемые коллекции:**
    - Hibernate использует прокси для управления коллекциями. Если коллекция заменена на неизменяемую (например, с использованием `Collections.unmodifiableList()`), Hibernate не сможет ее изменить или правильно отследить изменения.
- **Lombok:**
    - Использование аннотаций, таких как `@EqualsAndHashCode` или `@Data`, может привести к проблемам, если они не учитывают Hibernate-прокси. Это нарушает механизм `Dirty Checking`. ([[Entityt Manager, Session]])

**Решение:**
- Используйте `@EqualsAndHashCode(callSuper = true)` для правильной работы с Hibernate.


---
Tags: #entity
Author: [[]]
Related: [[JDBC, ORM, JPA and Hibernate]]
URL: [[]]