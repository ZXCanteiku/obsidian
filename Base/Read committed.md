## Read committed
aliases: 
	- "Read committed"

---

### Read committed

Транзакции на уровне изоляции "чтение зафиксированных данных" предотвращают "грязные" операции чтения, блокируя вторую операцию записи до завершения первой (фиксация или прерывание). Это позволяет избежать ряда проблем, связанных с конкурентным доступом.

Например, если транзакция обновляет несколько объектов, "грязные" записи могут привести к нежелательным результатам. Представьте сайт продаж автомобилей, где двое покупателей — Алиса и Боб — пытаются купить одну и ту же машину. Покупка включает две записи в базу: обновление списка автомобилей для указания покупателя и отправку счета-фактуры. Если Алиса обновляет таблицу "счета" позже, а Боб — таблицу "список" (рис. 7.5), то покупателем станет Боб, но счет получит Алиса. Уровень "чтение зафиксированных данных" предотвращает такие ситуации.
![[Pasted image 20241113204501.png]]

Однако этот уровень изоляции не защищает от состояния гонки при увеличении счётчиков (рис. 7.1). В данном случае обе записи происходят после фиксации первой транзакции, поэтому они не считаются "грязными". Несмотря на это, итоговые значения счетчиков будут некорректными, что требует дополнительных мер для предотвращения потери обновлений, о которых говорится в разделе "Предотвращение потери обновлений".
![[Pasted image 20241113204529.png]]


Чтение зафиксированных данных — популярный уровень изоляции, используемый по умолчанию в базах данных, таких как Oracle 11g, PostgreSQL и SQL Server 2012. Для предотвращения "грязных" записей базы данных обычно используют блокировки строк: перед изменением объекта транзакция устанавливает блокировку, которая удерживается до её завершения. Одновременно блокировку на объект может удерживать только одна транзакция, а другие ожидают её завершения, прежде чем продолжить.

Для предотвращения "грязных" чтений блокировки могли бы использоваться и для чтения, но это снижает отклик системы. Если многие транзакции должны ждать завершения одной долгой записи, производительность падает, и ожидания распространяются на другие части приложения.

Поэтому большинство баз данных предотвращают "грязные" чтения иначе (рис. 7.4): база сохраняет как старое зафиксированное значение объекта, так и новое, устанавливаемое транзакцией. Пока транзакция не зафиксирована, другим транзакциям возвращается старое значение; после фиксации — новое.

![[Pasted image 20241113204734.png]]

---
Tags:
Author: [[]]
Related: [[]]
URL: -- 