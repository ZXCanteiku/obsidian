### Модель памяти в Java:

aliases: 
	- "Модель памяти в Java"

**Из 
1. Java дает гарантию _[as-if-serial](https://en.wikipedia.org/wiki/As-if_rule)_ выполнения кода — вне зависимости от используемой JDK итоговый результат выполнения будет не отличим от такого порядка, как если бы действия выполнялись действительно последовательно согласно порядку в коде
2. Процессоры тоже делают только такие переупорядочивания, которые не изменят итогового результата выполнения инструкций
3. Процессоры имеют Cache Coherence механизм, который гарантирует консистентность данных среди локальных кэшей: как только значение попадает в локальный кэш одного ядра, оно будет видно всем остальным ядрам
**Из неочевидного:**
1. Java дает _as-if-serial_ гарантию только для единственного треда в изоляции. Это означает, что в многопоточной программе при работе с shared данными мы можем не увидеть записи там, где полагаемся на порядок выполнения действий в коде другого треда. Другими словами, для первого треда в изоляции валидно переупорядочивать инструкции местами, если это не повлияет на _его_ результат выполнения, но переупорядочивание может повлиять на _другие_ треды
2. Процессор также дает гарантию только для единственного ядра в изоляции
3. Cache Coherence действительно гарантирует чтение актуальных значений, но пропагация записи происходит не мгновенно, а с некоторой задержкой



Формально модель памяти определяет набор действий межпоточного взаимодействия (эти действия включают в себя, в частности, чтение и запись переменной, захват и освобождений монитора, чтение и запись volatile переменной, запуск нового потока), а также модель памяти определяет отношение между этими действиями -_happens-before_ - абстракции обозначающей, что если операция _A_ связана отношением happens-before с операцией _B_, то весь код следуемый за операцией _A_, выполняемый в одном потоке, видит все изменения, сделанные другим потоком, до операции _B_. Т.е. при исполнении команд по порядку, вторая команда видит все изменения, свершенные первой операцией.

**[[hapens-before]]**

Существует несколько основных правил для отношения happens-before:
- В рамках одного потока любая операция идущая в program order является - happens-before по отношению к любой операциией следующей за ней в исходном коде;
- Освобождение монитора (unlock) happens-before захват того же монитора (lock);
- Выход из `synchronized` блока/метода happens-before вход в `synchronized` блок/метод на том же мониторе;
- Запись `volatile` поля happens-before чтение того же самого `volatile` поля;
- Завершение метода `run()` экземпляра класса `Thread` happens-before выход из метода `join()` или возвращение `false` методом `isAlive()` экземпляром того же потока;
- Вызов метода `start()` экземпляра класса `Thread` happens-before начало метода `run()` экземпляра того же потока;
- Завершение конструктора happens-before начало метода `finalize()` этого класса;
- Вызов метода `interrupt()` на потоке happens-before обнаружению потоком факта, что данный метод был вызван либо путем выбрасывания исключения `InterruptedException`, либо с помощью методов `isInterrupted()` или `interrupted()`.
- Связь happens-before транзитивна, т.е. если _X_ happens-before _Y_, а _Y_ happens-before _Z_, то _X_ happens-before _Z_.
- Освобождение/захват монитора и запись/чтение в `volatile` переменную связаны отношением happens-before, только если операции проводятся над одним и тем же экземпляром объекта.
- В отношении happens-before участвуют только два потока, о поведении остальных потоков ничего сказать нельзя, пока в каждом из них не наступит отношение happens-before с другим потоком.
[Ссылка на статью](https://github.com/Shell26/Java-Developer/blob/master/concurrency.md#%D0%A0%D0%B0%D1%81%D1%81%D0%BA%D0%B0%D0%B6%D0%B8%D1%82%D0%B5-%D0%BE-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D0%B8-%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8-java)


---
Tags: #thread
Author: [[]]
Related: [[Многопоточность]]
URL: [[]]