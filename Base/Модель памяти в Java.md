### Модель памяти в Java:

aliases: 
	- "Модель памяти в Java"

**гарантия выполнения кодам
1. Java дает гарантию _[as-if-serial](https://en.wikipedia.org/wiki/As-if_rule)_ выполнения кода — вне зависимости от используемой JDK итоговый результат выполнения будет не отличим от такого порядка, как если бы действия выполнялись действительно последовательно согласно порядку в коде
2. Процессоры тоже делают только такие переупорядочивания, которые не изменят итогового результата выполнения инструкций
3. Процессоры имеют Cache Coherence механизм, который гарантирует консистентность данных среди локальных кэшей: как только значение попадает в локальный кэш одного ядра, оно будет видно всем остальным ядрам
4. 
**Из неочевидного:**
1. Java дает _as-if-serial_ гарантию только для единственного треда в изоляции. Это означает, что в многопоточной программе при работе с shared данными мы можем не увидеть записи там, где полагаемся на порядок выполнения действий в коде другого треда. Другими словами, для первого треда в изоляции валидно переупорядочивать инструкции местами, если это не повлияет на _его_ результат выполнения, но переупорядочивание может повлиять на _другие_ треды
2. Процессор также дает гарантию только для единственного ядра в изоляции
3. Cache Coherence действительно гарантирует чтение актуальных значений, но пропагация записи происходит не мгновенно, а с некоторой задержкой


**_Instructions reordering_**. Оба треда могут поменять местами инструкции записи и чтения, так как эти действия никак не связаны.
**_Visibility_**. Даже если переупорядочивания не было, записи могут быть просто не видны другому треду из-за оптимизаций компилятора или задержки при пропагации записи на уровне кеша.

#### Java Memory Model
- Разрешает выполнение различных оптимизаций компилятора, JVM или процессора.
- Строго закрепляет условия, при которых программа считается правильно синхронизированной, и закрепляет поведение правильно синхронизированных программ.
- Описывает отношение между высокоуровневым кодом и памятью.
- Является trade-off между строгостью исполнения кода и возможными оптимизациями.
По умолчанию JMM разрешает любые переупорядочивания и не гарантирует видимости изменений. Однако _при выполнении определенных условий_ нам гарантируется порядок действий,


#### Memory Ordering
**Memory Ordering** описывает _наблюдаемый программой_ порядок, в котором происходят действия с памятью.

_Memory Model_ описывает, какие переупорядочивания возможны. В зависимости от строгости модели памяти подразделяются на следующие типы:
1. _Sequential Consistency_: запрещены все переупорядочивания
2. _Relaxed Consistency_: разрешены некоторые переупорядочивания
3. _Weak Consistency_: разрешены все переупорядочивания


#### Sequential Consistency
**Sequential Consistency Model (SC)** — это очень строгая модель памяти, которая гарантирует отсутствие переупорядочиваний.
Java Memory Model — это **Sequential Consistency-Data Race Free (SC-DRF)** модель: нам предоставляется sequential consistency, но только в том случае, если мы избавимся от всех _data race_ в программе

**[[hapens-before]]**
**[[Cache Coherence]]**
**[[Memory Barriers]]**


Что делает JMM на каждом из уровней, чтобы правильно синхронизированная программа не имела переупорядочиваний. Happens-before — это конечно хорошо, но это всего лишь абстракция. А вот на нижнем уровне компилятора и хардвара JMM на самом деле делает следующее:
1. Compiler memory ordering  
    1. Уровень компилятора байткода (`javac`)  
        - Обеспечивает такой порядок сгенерированных bytecode инструкций, который будет консистентен с порядком действий в коде
    2. Уровень компилятора машинного кода (`HotSpot JIT Compiler C1/C2`)  
        - Обеспечивает такой порядок сгенерированных машинных инструкций, который будет консистентен с порядком действий в коде
2. CPU memory ordering  
    - Расставляет барьеры памяти в нужных местах так, чтобы memory ordering машинных инструкций был консистентен с порядком действий в коде

#### Важная часть JMM:
- Чтения и записи _reference переменных_ (ссылок) являются атомарными
- Чтения и записи _примитивов_ (кроме long/double) являются атомарными
- Чтения и записи _long/double переменных_, помеченных как `volatile`, являются атомарными
JMM дает очень полезную гарантию порядка и видимости записей для `final` полей: если ссылка на создаваемый объект не утекла во время работы конструктора (так, что ее мог увидеть другой тред), то все остальные треды, которые увидели non-null ссылку на этот объект, _гарантированно прочитают актуальные значения всех внутренних `final` полей объекта_ вне зависимости от того, была гонка при чтении ссылки или нет.
Это очень сильная гарантия, которая полностью избавляет нас от проблем memory reordering при чтении состояния объекта. Обычно интерпретация этих свойств звучит как _Safe Initialization_ (безопасная инициализация), которая по сути дает нам всегда безопасную пабликацию (safe publication).

Семантика `final` полей напрямую касается иммутабельных объектов. Известно, что такие объекты можно безопасно шарить между тредами. Но без данной гарантии JMM это было бы не правдой, ведь проблема переупорядочивания все еще никуда не делась. Именно благодаря тому, что JMM автоматически берет на себя задачу по синхронизации `final` полей, мы имеем возможность корректно шарить иммутабельные объекты без использования примитивов синхронизации.


---
Tags: #thread
Author: [[]]
Related: [[Многопоточность]]
URL: https://habr.com/ru/articles/685518/