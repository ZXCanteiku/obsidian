
aliases: 
	- "Generics"

**Дженерики** (Generics) в Java — это мощный механизм, позволяющий создавать классы, интерфейсы и методы с параметризованными типами. Они обеспечивают безопасность типов в коллекциях и других структурах данных, позволяя избежать явного приведения типов и снижая вероятность ошибок во время выполнения.

Примером использования обобщенных типов может служить _Java Collection Framework_. Так, класс `LinkedList<E>` - типичный обобщенный тип. Он содержит параметр `E`, который представляет тип элементов, которые будут храниться в коллекции. Создание объектов обобщенных типов происходит посредством замены параметризированных типов реальными типами данных. Вместо того, чтобы просто использовать `LinkedList`, ничего не говоря о типе элемента в списке, предлагается использовать точное указание типа `LinkedList<String>`, `LinkedList<Integer>` и т.п.

### Ковариантность, контравариантность и инвариантность

Сначала немного теории. **Ковариантность** — это сохранение иерархии наследования исходных типов в производных типах в том же порядке. Например, если Кошка — это подтип Животные, то Множество<Кошки> — это подтип Множество<Животные>. Следовательно, с учетом принципа подстановки можно выполнить такое присваивание:

Множество<Животные> = Множество<Кошки>

**Контравариантность** — это обращение иерархии исходных типов на противоположную в производных типах. Например, если Кошка — это подтип Животные, то Множество<Животные> — это подтип Множество<Кошки>. Следовательно, с учетом принципа подстановки можно выполнить такое присваивание:

Множество<Кошки> = Множество<Животные>

**Инвариантность** — отсутствие наследования между производными типами. Если Кошка — это подтип Животные, то Множество<Кошки> не является подтипом Множество<Животные> и Множество<Животные> не является подтипом Множество<Кошки>.

**Массивы в Java ковариантны. Тип S[] является подтипом T[], если S — подтип T. Пример присваивания:**

```java
String[] strings = new String[] {"a", "b", "c"};
Object[] arr = strings;
```

Мы присвоили ссылку на массив строк переменной arr, тип которой – «массив объектов». Если бы массивы не были ковариантными, нам бы это сделать не удалось. Java позволяет это сделать, программа скомпилируется и выполнится без ошибок.

```java
arr[0] = 42; // ArrayStoreException. Проблема обнаружилась на этапе выполнения программы
```

Но если мы попытаемся изменить содержимое массива через переменную arr и запишем туда число 42, то получим ArrayStoreException на этапе выполнения программы, поскольку 42 является не строкой, а числом. В этом недостаток ковариантности массивов Java: мы не 
можем выполнить проверки на этапе компиляции, и что-то может сломаться уже в рантайме.

**«Дженерики» инвариантны. Приведем пример:**

```java
List<Integer> ints = Arrays.asList(1,2,3);
List<Number> nums = ints; // compile-time error. Проблема обнаружилась на этапе компиляции
nums.set(2, 3.14);
assert ints.toString().equals("[1, 2, 3.14]");
```

Если взять список целых чисел, то он не будет являться ни подтипом типа Number, ни каким-либо другим подтипом. Он является только подтипом самого себя. То есть List — это List и ничего больше. Компилятор позаботится о том, чтобы переменная ints, объявленная как список объектов класса Integer, содержала только объекты класса Integer и ничего кроме них. На этапе компиляции производится проверка, и у нас в рантайме уже ничего не упадет.

Всегда ли Generics инварианты? Нет.



---
Tags: #generics
Author: [[]]
Related: [[Java Core]]
URL: [[]]