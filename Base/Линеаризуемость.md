## Что такое линеаризуемость
aliases: 
	- "Линеаризуемость"

---

### Линеаризуемость

**Общее определение**

- Линеаризуемость (или сильная/атомарная согласованность) гарантирует, что для пользователя система выглядит так, будто существует **только одна копия** данных.
- Каждая операция чтения/записи «как бы» выполняется **атомарно** в одну точку времени, и **все клиенты** видят результаты в одном и том же порядке.

**Пример (история с футболом)**

На рис. 1 показан пример нелинеазируемого спортивного сайта. Алиса и Боб сидят в одной комнате и смотрят на телефоны, чтобы узнать результат финала Кубка мира по футболу 2014 года. Как только объявлен окончательный результат, Алиса обновляет страницу, видит победителя и взволнованно рассказывает об этом Бобу. Боб недоверчиво перезагружает страницу на своем телефоне, но его запрос попадает на реплику базы данных, на которой случилась задержка, и поэтому его телефон показывает, что игра все еще продолжается.
![[Pasted image 20250122190441.png]]
Если бы Алиса и Боб одновременно обновили свои страницы, то меньше бы удивились, получив два разных результата запроса, поскольку точно не знали, в какое время их запросы обрабатывались сервером. Но Боб знает, что нажал кнопку перезагрузки (инициировал свой запрос) после того, как услышал от Алисы окончательный счет, и поэтому ожидает, что результат его запроса будет по крайней мере столь же свежим, как и у Алисы. Факт возврата старого результата на запрос Боба является нарушением линеаризуемости.

- Если бы линеаризуемость соблюдалась, то раз Алиса уже «достучалась» до самого свежего результата, Боб **не мог бы** получить устаревшие данные.
- Получается нарушение принципа: «если кто-то уже видит новое состояние (финал матча), то все последующие запросы обязаны видеть тот же результат или более свежий».

**Как выглядит в распределённых БД**

- Если система линеаризуема, сразу после записи нового значения все будущие чтения должны возвращать именно это новое значение.
- В классических однопроцессорных программах мы к этому привыкли (присвоил переменной `x=1` — все видят `x=1`). Но в распределённых системах, из-за репликации и сетевых задержек, такое «мгновенное» распространение может не сработать без специальной протокольной поддержки.

**Почему линеаризуемость усложняет дизайн**

1. **Высокие задержки**. Чтобы «договориться» о едином порядке всех операций, узлам нужно синхронно обмениваться сообщениями или подтверждениями (кворумы).
2. **Чувствительность к сбоям**. Если один узел или сетевой канал работает очень медленно, консенсусные шаги могут затягиваться.
3. **Производительность**. Любая попытка ускорить (например, «давайте сделаем репликацию асинхронной») грозит потерей линеаризуемости.

**Однако линеаризуемость удобна**

- Пригодна в задачах, где ошибка недопустима (уникальные имена пользователей, ограничения баланса, вывод «самых актуальных» данных).
- Программисту проще логически рассуждать: «присвоил → значит все видят». Без линеаризуемости приходится держать в голове кучу нюансов (где-то задержка реплики, где-то конфликт обновлений и т.п.).

---
Tags:
Author: [[]]
Related: [[]]
URL: -- 