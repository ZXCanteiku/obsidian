## Последовательное выполнение транзакций
aliases: 
	- "Последовательное выполнение транзакций"

---

### Последовательное выполнение транзакций

Простой способ избежать проблем с конкурентным доступом — это выполнять транзакции последовательно, в одном потоке. Это исключает необходимость обнаружения и предотвращения конфликтов между транзакциями, так как изоляция по определению является сериализуемой.

Хотя идея однопоточного выполнения транзакций очевидна, она была принята в СУБД только в 2007 году. Это стало возможным благодаря двум факторам:

- Дешевизна оперативной памяти позволила хранить активные данные в памяти, ускоряя выполнение транзакций.
- Понимание, что OLTP-транзакции обычно короткие, а аналитические запросы могут выполняться на снимке состояния, что упрощает использование изоляции снимков состояния.

Примером СУБД с последовательным выполнением транзакций являются **VoltDB**, **Redis**, **Datomic**. Такие системы могут работать быстрее многозадачных, так как избегают затрат на блокировки, но их пропускная способность ограничена одним ядром процессора.

#### Хранимые процедуры

Ранее считалось, что транзакция должна охватывать весь поток действий пользователя. Однако поддержание множества конкурентных транзакций для обработки интерактивных данных оказалось неэффективным. В современных веб-приложениях транзакции обычно завершаются в одном HTTP-запросе, чтобы избежать блокировки.

Системы с однопоточным выполнением транзакций используют **хранимые процедуры**, что позволяет ускорить выполнение, так как не требуется ожидать операций ввода/вывода. Примером таких систем являются **VoltDB** и **Redis**.

#### Достоинства и недостатки хранимых процедур

Хранимые процедуры имеют свои недостатки:

- У каждой СУБД свой язык для написания процедур, что ограничивает гибкость.
- Труднее структурировать, отлаживать и интегрировать с экосистемами инструментов мониторинга.
- СУБД чувствительны к производительности, и ошибки в хранимых процедурах могут серьезно повлиять на систему.

Однако современные СУБД, такие как **VoltDB** (Java, Groovy), **Datomic** (Java, Clojure), **Redis** (Lua), используют универсальные языки программирования для хранимых процедур, что помогает преодолеть эти проблемы.

### Секционирование

Однопоточное выполнение транзакций ограничивает пропускную способность системы. Для масштабирования на несколько ядер можно использовать **секционирование данных**, как это делает **VoltDB**. Разбиение данных на секции позволяет обрабатывать транзакции независимо по каждой секции, что увеличивает производительность, соответствуя количеству ядер CPU.

Однако для транзакций, затрагивающих несколько секций, требуется согласование выполнения, что увеличивает сложность системы.

---
Tags: #transactions #highLoad
Author: [[]]
Related: [[Сериализуемость]]
URL: -- 